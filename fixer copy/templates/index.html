<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UW Course Prerequisites</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0a0a0f;
            min-height: 100vh;
            color: #e4e4e4;
            overflow: hidden;
        }
        
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 56px;
            background: rgba(15, 15, 25, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 16px;
            z-index: 100;
        }
        
        .logo {
            font-weight: 600;
            font-size: 1em;
            color: #a78bfa;
            white-space: nowrap;
        }
        
        .search-box {
            display: flex;
            gap: 8px;
            flex: 1;
            max-width: 350px;
        }
        
        #courseInput {
            flex: 1;
            padding: 9px 14px;
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 8px;
            background: rgba(255,255,255,0.05);
            color: #e4e4e4;
            outline: none;
        }
        
        #courseInput:focus { border-color: #a78bfa; }
        #courseInput::placeholder { color: #6b7280; }
        
        #searchBtn {
            padding: 9px 18px;
            background: #7c3aed;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            font-weight: 500;
        }
        
        #searchBtn:hover { background: #6d28d9; }
        
        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .control-btn {
            padding: 7px 12px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: #9ca3af;
            font-size: 13px;
            cursor: pointer;
        }
        
        .control-btn:hover { background: rgba(255,255,255,0.1); color: #e4e4e4; }
        
        .graph-container {
            position: fixed;
            top: 56px;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        #graphCanvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        #graphCanvas:active { cursor: grabbing; }
        
        .side-panel {
            position: fixed;
            top: 56px;
            right: 0;
            width: 300px;
            bottom: 0;
            background: rgba(15, 15, 25, 0.95);
            backdrop-filter: blur(20px);
            border-left: 1px solid rgba(255,255,255,0.08);
            padding: 16px;
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.25s ease;
            z-index: 50;
        }
        
        .side-panel.open { transform: translateX(0); }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        
        .panel-title { font-weight: 600; color: #e4e4e4; font-size: 0.95em; }
        
        .close-btn {
            background: none;
            border: none;
            color: #6b7280;
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
        }
        
        .course-detail h2 {
            font-size: 1.2em;
            margin-bottom: 4px;
            color: #e4e4e4;
        }
        
        .course-detail .meta {
            color: #6b7280;
            font-size: 0.85em;
            margin-bottom: 16px;
        }
        
        .status-badge {
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 0.85em;
        }
        
        .status-badge.not-needed {
            background: rgba(107,114,128,0.15);
            color: #9ca3af;
        }
        
        .status-badge.recommended {
            background: rgba(234,179,8,0.15);
            color: #fcd34d;
        }
        
        .status-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        
        .status-btn {
            flex: 1;
            padding: 9px;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            font-weight: 500;
        }
        
        .status-btn.done { background: #065f46; color: #a7f3d0; }
        .status-btn.progress { background: #78350f; color: #fef3c7; }
        .status-btn.clear { background: rgba(255,255,255,0.08); color: #9ca3af; }
        
        .info-badge {
            position: fixed;
            top: 72px;
            left: 16px;
            background: rgba(15, 15, 25, 0.92);
            backdrop-filter: blur(10px);
            padding: 12px 16px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.08);
            z-index: 50;
            max-width: 280px;
        }
        
        .info-badge.hidden { display: none; }
        
        .info-badge.eligible {
            border-color: rgba(16, 185, 129, 0.4);
        }
        
        .info-badge h4 {
            font-size: 0.9em;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .info-badge.eligible h4 { color: #6ee7b7; }
        .info-badge p { font-size: 0.8em; color: #9ca3af; }
        .info-badge .highlight { color: #a78bfa; font-weight: 500; }
        
        .legend {
            position: fixed;
            bottom: 16px;
            left: 16px;
            background: rgba(15, 15, 25, 0.9);
            padding: 12px 14px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.08);
            font-size: 0.8em;
            z-index: 50;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            color: #9ca3af;
        }
        
        .legend-item:last-child { margin-bottom: 0; }
        
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .progress-bar {
            position: fixed;
            bottom: 16px;
            right: 16px;
            background: rgba(15, 15, 25, 0.9);
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.08);
            font-size: 0.8em;
            z-index: 50;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-width: 300px;
            transition: right 0.25s ease;
        }
        
        .progress-bar.panel-open { right: 316px; }
        
        .progress-bar .label { color: #6b7280; font-size: 0.75em; width: 100%; margin-bottom: 2px; }
        
        .mark-tag {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        .mark-tag.completed { background: #065f46; color: #a7f3d0; }
        .mark-tag.in-progress { background: #78350f; color: #fef3c7; }
        
        .mark-tag button {
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            font-size: 10px;
            cursor: pointer;
            color: inherit;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-controls {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: rgba(15, 15, 25, 0.9);
            padding: 4px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.08);
            z-index: 50;
        }
        
        .zoom-btn {
            width: 32px;
            height: 32px;
            background: rgba(255,255,255,0.06);
            border: none;
            border-radius: 6px;
            color: #9ca3af;
            font-size: 16px;
            cursor: pointer;
        }
        
        .zoom-btn:hover { background: rgba(255,255,255,0.12); color: #e4e4e4; }
        
        .loading {
            position: fixed;
            top: 56px;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 15, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            color: #6b7280;
        }
        
        .loading.hidden { display: none; }
        
        .help-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4b5563;
            font-size: 0.95em;
            text-align: center;
        }
        
        .help-text.hidden { display: none; }
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="logo">ðŸŽ“ UW Prerequisites</div>
        <div class="search-box">
            <input type="text" id="courseInput" placeholder="Course code (e.g., MATH138)" autocomplete="off">
            <button id="searchBtn">Search</button>
        </div>
        <div class="controls">
            <button class="control-btn" onclick="resetView()">Reset</button>
            <button class="control-btn" onclick="fitToScreen()">Fit</button>
            <button class="control-btn" onclick="togglePanel()">Details</button>
        </div>
    </div>
    
    <div class="graph-container">
        <canvas id="graphCanvas"></canvas>
    </div>
    
    <div class="help-text" id="helpText">
        Enter a course code to visualize prerequisites
    </div>
    
    <div class="info-badge hidden" id="infoBadge"></div>
    
    <div class="loading hidden" id="loading">Loading...</div>
    
    <div class="side-panel" id="sidePanel">
        <div class="panel-header">
            <span class="panel-title">Course Details</span>
            <button class="close-btn" onclick="togglePanel()">Ã—</button>
        </div>
        <div id="panelContent">
            <p style="color: #6b7280;">Click a node to see details</p>
        </div>
    </div>
    
    <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background: #a78bfa;"></div> Target</div>
        <div class="legend-item"><div class="legend-dot" style="background: #3b82f6;"></div> Prerequisite</div>
        <div class="legend-item"><div class="legend-dot" style="background: #10b981;"></div> Done</div>
        <div class="legend-item"><div class="legend-dot" style="background: #f59e0b;"></div> In Progress</div>
        <div class="legend-item"><div class="legend-dot" style="background: #374151; opacity:0.5;"></div> Not needed</div>
    </div>
    
    <div class="progress-bar" id="progressBar">
        <div class="label">YOUR PROGRESS</div>
        <span style="color: #6b7280; font-style: italic;">None yet</span>
    </div>
    
    <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomIn()">+</button>
        <button class="zoom-btn" onclick="zoomOut()">âˆ’</button>
    </div>
    
    <script>
        const completedCourses = new Set();
        const inProgressCourses = new Set();
        let currentData = null;
        let nodes = [];
        let edges = [];
        let orGroups = [];
        let selectedNode = null;
        
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        let scale = 1, offsetX = 0, offsetY = 0;
        let isDragging = false, dragStartX = 0, dragStartY = 0;
        let hoveredNode = null;
        
        function resizeCanvas() {
            const dpr = window.devicePixelRatio;
            canvas.width = window.innerWidth * dpr;
            canvas.height = (window.innerHeight - 56) * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = (window.innerHeight - 56) + 'px';
            ctx.scale(dpr, dpr);
            draw();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        document.getElementById('searchBtn').addEventListener('click', search);
        document.getElementById('courseInput').addEventListener('keypress', e => {
            if (e.key === 'Enter') search();
        });
        
        canvas.addEventListener('mousedown', e => {
            const pos = getMousePos(e);
            const node = findNodeAt(pos.x, pos.y);
            if (node) {
                selectNode(node);
            } else {
                isDragging = true;
                dragStartX = e.clientX - offsetX;
                dragStartY = e.clientY - offsetY;
            }
        });
        
        canvas.addEventListener('mousemove', e => {
            const pos = getMousePos(e);
            if (isDragging) {
                offsetX = e.clientX - dragStartX;
                offsetY = e.clientY - dragStartY;
                draw();
            } else {
                const node = findNodeAt(pos.x, pos.y);
                if (node !== hoveredNode) {
                    hoveredNode = node;
                    canvas.style.cursor = node ? 'pointer' : 'grab';
                    draw();
                }
            }
        });
        
        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);
        
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const pos = getMousePos(e);
            const wx = (pos.x - offsetX) / scale;
            const wy = (pos.y - offsetY) / scale;
            scale = Math.max(0.3, Math.min(2.5, scale * delta));
            offsetX = pos.x - wx * scale;
            offsetY = pos.y - wy * scale;
            draw();
        });
        
        canvas.addEventListener('dblclick', e => {
            const pos = getMousePos(e);
            const node = findNodeAt(pos.x, pos.y);
            if (node && node.code !== currentData?.course_code.replace(' ', '')) {
                document.getElementById('courseInput').value = node.code;
                search();
            }
        });
        
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        
        function findNodeAt(x, y) {
            const wx = (x - offsetX) / scale;
            const wy = (y - offsetY) / scale;
            for (const node of nodes) {
                const dx = wx - node.x, dy = wy - node.y;
                if (dx * dx + dy * dy < node.r * node.r) return node;
            }
            return null;
        }
        
        async function search() {
            const code = document.getElementById('courseInput').value.trim();
            if (!code) return;
            
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('helpText').classList.add('hidden');
            
            try {
                const res = await fetch('/api/course/' + encodeURIComponent(code));
                const data = await res.json();
                if (data.error) {
                    alert(data.error);
                } else {
                    currentData = data;
                    buildGraph(data);
                    updateInfo();
                    fitToScreen();
                }
            } catch (err) {
                alert('Error: ' + err.message);
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        }
        
        function buildGraph(data) {
            nodes = [];
            edges = [];
            orGroups = [];
            const nodeMap = new Map();
            const levels = new Map();
            
            function addNode(code, title, level, isTarget, parentCode, orGroupId) {
                if (!nodeMap.has(code)) {
                    const node = { code, title: title || '', level, x: 0, y: 0, r: isTarget ? 42 : 32, isTarget };
                    nodes.push(node);
                    nodeMap.set(code, node);
                    if (!levels.has(level)) levels.set(level, []);
                    levels.get(level).push(node);
                }
                
                if (parentCode && nodeMap.has(parentCode)) {
                    if (!edges.find(e => e.from.code === code && e.to.code === parentCode)) {
                        edges.push({ from: nodeMap.get(code), to: nodeMap.get(parentCode), orGroupId });
                    }
                }
                return nodeMap.get(code);
            }
            
            const targetCode = data.course_code.replace(' ', '');
            addNode(targetCode, data.title, 0, true, null, null);
            
            function processPrereqs(rule, tree, parentCode, level, orGroupId) {
                if (!rule) return;
                const reqs = rule.requirements || [];
                const isOr = rule.logic === 'OR';
                
                let currentOrId = orGroupId;
                if (isOr && reqs.length > 1) {
                    currentOrId = 'or-' + Math.random().toString(36).substr(2, 6);
                    orGroups.push({ id: currentOrId, parentCode, members: [], gradeMin: rule.grade_min });
                }
                
                for (const req of reqs) {
                    if (req.type === 'course') {
                        const code = req.course_code;
                        const info = tree[code] || {};
                        addNode(code, info.title, level, false, parentCode, currentOrId);
                        
                        if (currentOrId) {
                            const group = orGroups.find(g => g.id === currentOrId);
                            if (group && !group.members.includes(code)) group.members.push(code);
                        }
                        
                        if (info.prerequisites) {
                            processPrereqs(info.prerequisites, info.prerequisite_tree || {}, code, level + 1, null);
                        }
                    } else if (req.type === 'rule' || req.logic) {
                        processPrereqs(req, tree, parentCode, level, currentOrId);
                    }
                }
            }
            
            if (data.prerequisites) {
                processPrereqs(data.prerequisites, data.prerequisite_tree || {}, targetCode, 1, null);
            }
            
            computeStates();
            layoutNodes(levels);
        }
        
        function computeStates() {
            for (const group of orGroups) {
                let satisfiedBy = null;
                let minCost = Infinity, recommended = null;
                
                for (const code of group.members) {
                    if (isSatisfied(code)) { satisfiedBy = code; break; }
                    const cost = 1;
                    if (cost < minCost) { minCost = cost; recommended = code; }
                }
                
                group.satisfiedBy = satisfiedBy;
                group.recommended = satisfiedBy ? null : recommended;
                
                for (const code of group.members) {
                    const node = nodes.find(n => n.code === code);
                    if (node) {
                        node.isNotNeeded = satisfiedBy && code !== satisfiedBy;
                        node.isRecommended = !satisfiedBy && code === recommended;
                        node.orGroupId = group.id;
                    }
                }
            }
        }
        
        function isSatisfied(code) {
            return completedCourses.has(code) || inProgressCourses.has(code);
        }
        
        function layoutNodes(levels) {
            const arr = Array.from(levels.entries()).sort((a, b) => a[0] - b[0]);
            const levelH = 130;
            const centerX = canvas.width / (2 * window.devicePixelRatio);
            const startY = 70;
            
            for (const [level, lvlNodes] of arr) {
                const spacing = Math.min(140, (canvas.width / window.devicePixelRatio - 80) / Math.max(1, lvlNodes.length));
                const totalW = (lvlNodes.length - 1) * spacing;
                const startX = centerX - totalW / 2;
                lvlNodes.forEach((node, i) => {
                    node.x = startX + i * spacing;
                    node.y = startY + level * levelH;
                });
            }
        }
        
        function updateInfo() {
            const badge = document.getElementById('infoBadge');
            if (!currentData) { badge.classList.add('hidden'); return; }
            
            badge.classList.remove('hidden');
            const rule = currentData.prerequisites;
            
            if (!rule) {
                badge.classList.add('eligible');
                badge.innerHTML = `<h4>âœ… No Prerequisites</h4><p>You can take <span class="highlight">${currentData.course_code}</span> directly</p>`;
                return;
            }
            
            // Check if satisfied
            let satisfiedBy = null;
            if (rule.logic === 'OR') {
                for (const req of rule.requirements || []) {
                    if (req.type === 'course' && isSatisfied(req.course_code)) {
                        satisfiedBy = req.course_code;
                        break;
                    }
                }
            }
            
            if (satisfiedBy) {
                badge.classList.add('eligible');
                badge.innerHTML = `<h4>âœ… Eligible</h4><p>Satisfied by <span class="highlight">${satisfiedBy}</span></p>`;
            } else {
                badge.classList.remove('eligible');
                const total = (rule.requirements || []).filter(r => r.type === 'course').length;
                badge.innerHTML = `<h4>ðŸ“‹ Prerequisites</h4><p>${rule.logic === 'OR' ? `Complete <span class="highlight">1 of ${total}</span> options` : 'Complete all requirements'}</p>`;
            }
        }
        
        function draw() {
            ctx.save();
            ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = 'rgba(255,255,255,0.02)';
            ctx.lineWidth = 1;
            const grid = 40 * scale;
            for (let x = offsetX % grid; x < canvas.width / window.devicePixelRatio; x += grid) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = offsetY % grid; y < canvas.height / window.devicePixelRatio; y += grid) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
            
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            
            // OR group boxes
            for (const group of orGroups) {
                const memberNodes = nodes.filter(n => group.members.includes(n.code));
                if (memberNodes.length < 2) continue;
                
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                for (const n of memberNodes) {
                    minX = Math.min(minX, n.x - n.r - 8);
                    maxX = Math.max(maxX, n.x + n.r + 8);
                    minY = Math.min(minY, n.y - n.r - 8);
                    maxY = Math.max(maxY, n.y + n.r + 8);
                }
                
                ctx.strokeStyle = group.satisfiedBy ? 'rgba(16, 185, 129, 0.25)' : 'rgba(251, 191, 36, 0.15)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 4]);
                roundRect(ctx, minX, minY, maxX - minX, maxY - minY, 10);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Label
                ctx.fillStyle = group.satisfiedBy ? 'rgba(16, 185, 129, 0.7)' : 'rgba(251, 191, 36, 0.6)';
                ctx.font = '9px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                const label = group.satisfiedBy ? `âœ“ satisfied` : `pick 1${group.gradeMin ? ` (â‰¥${group.gradeMin}%)` : ''}`;
                ctx.fillText(label, (minX + maxX) / 2, minY - 4);
            }
            
            // Edges
            for (const edge of edges) {
                const from = edge.from, to = edge.to;
                const fromNotNeeded = from.isNotNeeded && !isSatisfied(from.code);
                const opacity = fromNotNeeded ? 0.15 : 0.4;
                
                ctx.beginPath();
                ctx.moveTo(from.x, from.y - from.r);
                const midY = (from.y - from.r + to.y + to.r) / 2;
                ctx.bezierCurveTo(from.x, midY, to.x, midY, to.x, to.y + to.r);
                
                ctx.strokeStyle = fromNotNeeded ? `rgba(75, 85, 99, ${opacity})` : `rgba(139, 92, 246, ${opacity})`;
                ctx.lineWidth = fromNotNeeded ? 1 : 1.5;
                ctx.setLineDash(fromNotNeeded ? [3, 3] : []);
                ctx.stroke();
                ctx.setLineDash([]);
                
                if (!fromNotNeeded) {
                    ctx.fillStyle = `rgba(139, 92, 246, 0.5)`;
                    ctx.beginPath();
                    ctx.moveTo(to.x, to.y + to.r);
                    ctx.lineTo(to.x - 5, to.y + to.r + 8);
                    ctx.lineTo(to.x + 5, to.y + to.r + 8);
                    ctx.fill();
                }
            }
            
            // Nodes
            for (const node of nodes) {
                const done = completedCourses.has(node.code);
                const prog = inProgressCourses.has(node.code);
                const notNeeded = node.isNotNeeded && !done && !prog;
                const rec = node.isRecommended && !done && !prog;
                const hovered = hoveredNode === node;
                const selected = selectedNode === node;
                
                const alpha = notNeeded ? 0.25 : 1;
                
                // Glow
                if ((hovered || selected) && !notNeeded) {
                    ctx.shadowColor = rec ? '#eab308' : '#a78bfa';
                    ctx.shadowBlur = 15;
                }
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.r, 0, Math.PI * 2);
                
                // Fill
                ctx.globalAlpha = alpha;
                if (done) ctx.fillStyle = '#065f46';
                else if (prog) ctx.fillStyle = '#78350f';
                else if (node.isTarget) ctx.fillStyle = '#5b21b6';
                else if (rec) ctx.fillStyle = '#713f12';
                else ctx.fillStyle = '#1e3a5f';
                ctx.fill();
                
                // Border
                ctx.lineWidth = selected ? 2.5 : 2;
                if (notNeeded) ctx.strokeStyle = '#4b5563';
                else if (done) ctx.strokeStyle = '#10b981';
                else if (prog) ctx.strokeStyle = '#f59e0b';
                else if (rec) ctx.strokeStyle = '#eab308';
                else if (node.isTarget) ctx.strokeStyle = '#a78bfa';
                else ctx.strokeStyle = '#3b82f6';
                ctx.stroke();
                
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
                
                // Text
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#fff';
                ctx.font = `600 ${node.isTarget ? 13 : 11}px -apple-system, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.code, node.x, node.y - 3);
                
                // Status
                ctx.font = '8px -apple-system, sans-serif';
                if (done) { ctx.fillStyle = '#6ee7b7'; ctx.fillText('âœ“ Done', node.x, node.y + 10); }
                else if (prog) { ctx.fillStyle = '#fcd34d'; ctx.fillText('In Progress', node.x, node.y + 10); }
                else if (notNeeded) { ctx.fillStyle = '#6b7280'; ctx.fillText('not needed', node.x, node.y + 10); }
                else if (rec) { ctx.fillStyle = '#fcd34d'; ctx.fillText('â˜… recommended', node.x, node.y + 10); }
                
                ctx.globalAlpha = 1;
            }
            
            ctx.restore();
        }
        
        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
        }
        
        function selectNode(node) {
            selectedNode = node;
            showDetails(node);
            draw();
        }
        
        function showDetails(node) {
            const panel = document.getElementById('sidePanel');
            const content = document.getElementById('panelContent');
            const done = completedCourses.has(node.code);
            const prog = inProgressCourses.has(node.code);
            const notNeeded = node.isNotNeeded && !done && !prog;
            const rec = node.isRecommended && !done && !prog;
            
            let html = '<div class="course-detail">';
            html += `<h2>${node.code}</h2>`;
            html += `<div class="meta">${node.title || ''}</div>`;
            
            if (notNeeded) {
                html += '<div class="status-badge not-needed">Not needed â€” another option is satisfied</div>';
            } else if (rec) {
                html += '<div class="status-badge recommended">â˜… Recommended â€” fewest prerequisites</div>';
            }
            
            html += '<div class="status-buttons">';
            html += `<button class="status-btn done" onclick="mark('${node.code}','done')">âœ“ Done</button>`;
            html += `<button class="status-btn progress" onclick="mark('${node.code}','progress')">In Progress</button>`;
            if (done || prog) html += `<button class="status-btn clear" onclick="mark('${node.code}','clear')">Clear</button>`;
            html += '</div>';
            
            if (node.code !== currentData?.course_code.replace(' ', '')) {
                html += `<button class="control-btn" style="width:100%;margin-top:12px;" onclick="focusCourse('${node.code}')">Focus on this course</button>`;
            }
            
            html += '</div>';
            content.innerHTML = html;
            panel.classList.add('open');
            document.getElementById('progressBar').classList.add('panel-open');
        }
        
        function togglePanel() {
            document.getElementById('sidePanel').classList.toggle('open');
            document.getElementById('progressBar').classList.toggle('panel-open');
        }
        
        function mark(code, status) {
            completedCourses.delete(code);
            inProgressCourses.delete(code);
            if (status === 'done') completedCourses.add(code);
            if (status === 'progress') inProgressCourses.add(code);
            
            computeStates();
            updateProgress();
            updateInfo();
            draw();
            if (selectedNode) showDetails(selectedNode);
        }
        
        function updateProgress() {
            const bar = document.getElementById('progressBar');
            const all = [...completedCourses, ...inProgressCourses];
            
            if (all.length === 0) {
                bar.innerHTML = '<div class="label">YOUR PROGRESS</div><span style="color: #6b7280; font-style: italic;">None yet</span>';
                return;
            }
            
            bar.innerHTML = '<div class="label">YOUR PROGRESS</div>' + all.map(code => {
                const cls = completedCourses.has(code) ? 'completed' : 'in-progress';
                return `<div class="mark-tag ${cls}">${code}<button onclick="mark('${code}','clear')">Ã—</button></div>`;
            }).join('');
        }
        
        function focusCourse(code) {
            document.getElementById('courseInput').value = code;
            search();
        }
        
        function resetView() { scale = 1; offsetX = 0; offsetY = 0; draw(); }
        function zoomIn() { scale = Math.min(2.5, scale * 1.2); draw(); }
        function zoomOut() { scale = Math.max(0.3, scale * 0.8); draw(); }
        
        function fitToScreen() {
            if (nodes.length === 0) return;
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const n of nodes) {
                minX = Math.min(minX, n.x - n.r);
                maxX = Math.max(maxX, n.x + n.r);
                minY = Math.min(minY, n.y - n.r);
                maxY = Math.max(maxY, n.y + n.r);
            }
            const pad = 80;
            const gw = maxX - minX + pad * 2;
            const gh = maxY - minY + pad * 2;
            const cw = canvas.width / window.devicePixelRatio;
            const ch = canvas.height / window.devicePixelRatio;
            scale = Math.min(cw / gw, ch / gh, 1.5);
            offsetX = cw / 2 - (minX + maxX) / 2 * scale;
            offsetY = ch / 2 - (minY + maxY) / 2 * scale;
            draw();
        }
        
        draw();
    </script>
</body>
</html>
